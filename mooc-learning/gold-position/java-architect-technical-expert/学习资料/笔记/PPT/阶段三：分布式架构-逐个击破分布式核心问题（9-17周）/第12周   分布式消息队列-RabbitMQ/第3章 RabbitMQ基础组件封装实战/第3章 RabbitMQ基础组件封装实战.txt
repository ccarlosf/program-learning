第3章 RabbitMQ基础组件封装实战
3-1 RabbitMQ基础组件整体功能概述（3分钟）



3-2 RabbitMQ基础组件模块划分（9分钟）
1.父pom文件依赖
<parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.1.5.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <groupId>com.ccarlos.base.rabbit</groupId>
    <artifactId>rabbit-parent</artifactId>
    <packaging>pom</packaging>
    <name>rabbit-parent</name>
    <description>rabbit-parent</description>
    <modules>
        <module>rabbit-common</module>
        <module>rabbit-api</module>
        <module>rabbit-core-producer</module>
        <module>rabbit-task</module>
    </modules>
    <version>0.0.1-SNAPSHOT</version>

    <modelVersion>4.0.0</modelVersion>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <java.version>8</java.version>
        <fasterxml.uuid.version>3.1.4</fasterxml.uuid.version>
        <org.codehaus.jackson.version>1.9.13</org.codehaus.jackson.version>
        <druid.version>1.0.24</druid.version>
        <elastic-job.version>2.1.4</elastic-job.version>
        <guava.version>20.0</guava.version>
        <commons-lang3.version>3.3.1</commons-lang3.version>
        <commons-io.version>2.4</commons-io.version>
        <commons-collections.version>3.2.2</commons-collections.version>
        <curator.version>2.11.0</curator.version>
        <fastjson.version>1.1.26</fastjson.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>com.google.guava</groupId>
            <artifactId>guava</artifactId>
            <version>${guava.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
        </dependency>
        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
            <version>${commons-io.version}</version>
        </dependency>
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
            <version>${fastjson.version}</version>
        </dependency>
        <!--对json格式的支持 -->
        <dependency>
            <groupId>org.codehaus.jackson</groupId>
            <artifactId>jackson-mapper-asl</artifactId>
            <version>${org.codehaus.jackson.version}</version>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.uuid</groupId>
            <artifactId>java-uuid-generator</artifactId>
            <version>${fasterxml.uuid.version}</version>
        </dependency>
    </dependencies>

3-3 RabbitMQ基础组件API封装-1（23分钟）
3-3 RabbitMQ基础组件API封装-1（23分钟）
1.Message类
@Data
  public class Message implements Serializable {

      private static final long serialVersionUID = 841277940410721237L;

      /* 	消息的唯一ID	*/
      private String messageId;

      /*	消息的主题		*/
      private String topic;

      /*	消息的路由规则	*/
      private String routingKey = "";

      /*	消息的附加属性	*/
      private Map<String, Object> attributes = new HashMap<String, Object>();

      /*	延迟消息的参数配置	*/
      private int delayMills;

      /*	消息类型：默认为confirm消息类型	*/
      private String messageType = MessageType.CONFIRM;

      public Message() {
      }

      public Message(String messageId, String topic, String routingKey, Map<String, Object> attributes, int delayMills) {
          this.messageId = messageId;
          this.topic = topic;
          this.routingKey = routingKey;
          this.attributes = attributes;
          this.delayMills = delayMills;
      }

      public Message(String messageId, String topic, String routingKey, Map<String, Object> attributes, int delayMills,
                     String messageType) {
          this.messageId = messageId;
          this.topic = topic;
          this.routingKey = routingKey;
          this.attributes = attributes;
          this.delayMills = delayMills;
          this.messageType = messageType;
      }

  }

2.MessageBuilder类
/**
 * 	$MessageBuilder 建造者模式
 *
 */
public class MessageBuilder {

	private String messageId;
	private String topic;
	private String routingKey = "";
	private Map<String, Object> attributes = new HashMap<String, Object>();
	private int delayMills;
	private String messageType = MessageType.CONFIRM;

	private MessageBuilder() {
	}

	public static MessageBuilder create() {
		return new MessageBuilder();
	}

	public MessageBuilder withMessageId(String messageId) {
		this.messageId = messageId;
		return this;
	}

	public MessageBuilder withTopic(String topic) {
		this.topic = topic;
		return this;
	}

	public MessageBuilder withRoutingKey(String routingKey) {
		this.routingKey = routingKey;
		return this;
	}

	public MessageBuilder withAttributes(Map<String, Object> attributes) {
		this.attributes = attributes;
		return this;
	}

	public MessageBuilder withAttribute(String key, Object value) {
		this.attributes.put(key, value);
		return this;
	}

	public MessageBuilder withDelayMills(int delayMills) {
		this.delayMills = delayMills;
		return this;
	}

	public MessageBuilder withMessageType(String messageType) {
		this.messageType = messageType;
		return this;
	}

	public Message build() {

		// 1. check messageId
		if(messageId == null) {
			messageId = UUID.randomUUID().toString();
		}
		// 2. topic is null
		if(topic == null) {
			throw new MessageRunTimeException("this topic is null");
		}
		Message message = new Message(messageId, topic, routingKey, attributes, delayMills, messageType);
		return message;
	}

}

3.MessageException类
/**
 * 	$MessageException
 *
 */
public class MessageException extends Exception {

	private static final long serialVersionUID = 6347951066190728758L;

	public MessageException() {
		super();
	}

	public MessageException(String message) {
		super(message);
	}

	public MessageException(String message, Throwable cause) {
		super(message, cause);
	}

	public MessageException(Throwable cause) {
		super(cause);
	}

}

4.MessageRunTimeException类
/**
 * 	$MessageRunTimeException
 *
 */
public class MessageRunTimeException extends RuntimeException {

	private static final long serialVersionUID = 8651828913888663267L;

	public MessageRunTimeException() {
		super();
	}

	public MessageRunTimeException(String message) {
		super(message);
	}

	public MessageRunTimeException(String message, Throwable cause) {
		super(message, cause);
	}

	public MessageRunTimeException(Throwable cause) {
		super(cause);
	}
}

5.MessageType类
public final class MessageType {

    /**
     * 迅速消息：不需要保障消息的可靠性, 也不需要做confirm确认
     */
    public static final String RAPID = "0";

    /**
     * 确认消息：不需要保障消息的可靠性，但是会做消息的confirm确认
     */
    public static final String CONFIRM = "1";

    /**
     * 可靠性消息： 一定要保障消息的100%可靠性投递，不允许有任何消息的丢失
     * PS: 保障数据库和所发的消息是原子性的（最终一致的）
     */
    public static final String RELIANT = "2";

}



3-4 RabbitMQ基础组件API封装-2（4分钟）



3-5 自动装配与架构接口定义（10分钟）
3-5 自动装配与架构接口定义（10分钟）
1.rabbit-common pom文件
<dependencies>
        <dependency>
            <groupId>com.ccarlos.base.rabbit</groupId>
            <artifactId>rabbit-api</artifactId>
            <version>0.0.1-SNAPSHOT</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>
    </dependencies>

2.rabbit-core-producer
<dependencies>
        <dependency>
            <groupId>com.ccarlos.base.rabbit</groupId>
            <artifactId>rabbit-common</artifactId>
            <version>0.0.1-SNAPSHOT</version>
        </dependency>
        <dependency>
            <groupId>com.ccarlos.base.rabbit</groupId>
            <artifactId>rabbit-task</artifactId>
            <version>0.0.1-SNAPSHOT</version>
        </dependency>
    </dependencies>

3.ProducerClient
/**
 * 	$ProducerClient 发送消息的实际实现类
 *
 */
@Component
public class ProducerClient implements MessageProducer {

	@Override
	public void send(Message message, SendCallback sendCallback) throws MessageRunTimeException {

	}

	@Override
	public void send(Message message) throws MessageRunTimeException {

	}

	@Override
	public void send(List<Message> messages) throws MessageRunTimeException {

	}
}

4.RabbitProducerAutoConfiguration
/**
 * 	$RabbitProducerAutoConfiguration 自动装配
 *
 */
@Configuration
public class RabbitProducerAutoConfiguration {


}

5.spring.factories
# Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.ccarlos.rabbit.producer.autoconfigure.RabbitProducerAutoConfiguration



3-6 发送迅速异步消息（18分钟）
1.AsyncBaseQueue
@Slf4j
public class AsyncBaseQueue {

	private static final int THREAD_SIZE = Runtime.getRuntime().availableProcessors();

	private static final int QUEUE_SIZE = 10000;

	private static ExecutorService senderAsync =
			new ThreadPoolExecutor(THREAD_SIZE,
					THREAD_SIZE,
					60L,
					TimeUnit.SECONDS,
					new ArrayBlockingQueue<Runnable>(QUEUE_SIZE),
					new ThreadFactory() {
						@Override
						public Thread newThread(Runnable r) {
							Thread t = new Thread(r);
							t.setName("rabbitmq_client_async_sender");
							return t;
						}
					},
					new java.util.concurrent.RejectedExecutionHandler() {
						@Override
						public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
							log.error("async sender is error rejected, runnable: {}, executor: {}", r, executor);
						}
					});

		public static void submit(Runnable runnable) {
			senderAsync.submit(runnable);
		}

}

2.ProducerClient
@Override
	public void send(Message message) throws MessageRunTimeException {
		Preconditions.checkNotNull(message.getTopic());
		String messageType = message.getMessageType();
		switch (messageType) {
			case MessageType.RAPID:
				rabbitBroker.rapidSend(message);
				break;
			case MessageType.CONFIRM:
				rabbitBroker.confirmSend(message);
				break;
			case MessageType.RELIANT:
				rabbitBroker.reliantSend(message);
				break;
			default:
				break;
		}

	}

3.RabbitBroker
/**
 * 	$RabbitBroker 具体发送不同种类型消息的接口
 *
 */
public interface RabbitBroker {

	void rapidSend(Message message);

	void confirmSend(Message message);

	void reliantSend(Message message);

	void sendMessages();

}

4.RabbitBrokerImpl
/**
 * $RabbitBrokerImpl 真正的发送不同类型的消息实现类
 */
@Slf4j
@Component
public class RabbitBrokerImpl implements RabbitBroker {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    /**
     * $rapidSend迅速发消息
     */
    @Override
    public void rapidSend(Message message) {
        message.setMessageType(MessageType.RAPID);
        sendKernel(message);
    }


/*    private void sendKernel(Message message) {

        CorrelationData correlationData = new CorrelationData(String.format("%s#%s",
                message.getMessageId(),
                System.currentTimeMillis()));

        String topic = message.getTopic();
        String routingKey = message.getRoutingKey();
        rabbitTemplate.convertAndSend(topic, routingKey, message, correlationData);
        log.info("#RabbitBrokerImpl.sendKernel# send to rabbitmq, messageId: {}", message.getMessageId());

    }*/
    /**
     * $sendKernel 发送消息的核心方法 使用异步线程池进行发送消息
     *
     * @param message
     */
    private void sendKernel(Message message) {

        AsyncBaseQueue.submit((Runnable) () -> {
            CorrelationData correlationData =
                    new CorrelationData(String.format("%s#%s#%s",
                            message.getMessageId(),
                            System.currentTimeMillis(),
                            message.getMessageType()));
            String topic = message.getTopic();
            String routingKey = message.getRoutingKey();
            RabbitTemplate rabbitTemplate = rabbitTemplate.getTemplate(message);
            rabbitTemplate.convertAndSend(topic, routingKey, message, correlationData);
            log.info("#RabbitBrokerImpl.sendKernel# send to rabbitmq, messageId: {}", message.getMessageId());
        });
    }

    @Override
    public void confirmSend(Message message) {
    }

    @Override
    public void reliantSend(Message message) {

    }

    @Override
    public void sendMessages() {

    }

}

5.RabbitProducerAutoConfiguration
@ComponentScan({"com.ccarlos.rabbit.producer.*"})



3-7 RabbitTemplate池化封装（25分钟）
1.RabbitTemplateContainer
/**
 * 	$RabbitTemplateContainer池化封装
 * 	每一个topic 对应一个RabbitTemplate
 *	1.	提高发送的效率
 * 	2. 	可以根据不同的需求制定化不同的RabbitTemplate, 比如每一个topic 都有自己的routingKey规则
 * @author ccarlos
 */
@Slf4j
@Component
public class RabbitTemplateContainer implements RabbitTemplate.ConfirmCallback {

	private Map<String /* TOPIC */, RabbitTemplate> rabbitMap = Maps.newConcurrentMap();

	private Splitter splitter = Splitter.on("#");

	@Autowired
	private ConnectionFactory connectionFactory;

	public RabbitTemplate getTemplate(Message message) throws MessageRunTimeException {
		Preconditions.checkNotNull(message);
		String topic = message.getTopic();
		RabbitTemplate rabbitTemplate = rabbitMap.get(topic);
		if(rabbitTemplate != null) {
			return rabbitTemplate;
		}
		log.info("#RabbitTemplateContainer.getTemplate# topic: {} is not exists, create one", topic);

		RabbitTemplate newTemplate = new RabbitTemplate(connectionFactory);
		newTemplate.setExchange(topic);
		newTemplate.setRoutingKey(message.getRoutingKey());
		newTemplate.setRetryTemplate(new RetryTemplate());

		// 对于message的序列化方式
		// newTemplate.setMessageConverter(messageConverter);

		String messageType = message.getMessageType();
		if(!MessageType.RAPID.equals(messageType)) {
			newTemplate.setConfirmCallback(this);
		}

		rabbitMap.putIfAbsent(topic, newTemplate);

		return rabbitMap.get(topic);
	}

	/**
	 * 	无论是 confirm 消息 还是 reliant 消息 ，发送消息以后 broker都会去回调confirm
	 */
	@Override
	public void confirm(CorrelationData correlationData, boolean ack, String cause) {
		// 	具体的消息应答
		List<String> strings = splitter.splitToList(correlationData.getId());
		String messageId = strings.get(0);
		long sendTime = Long.parseLong(strings.get(1));
		if(ack) {
			//	当Broker 返回ACK成功时, 就是更新一下日志表里对应的消息发送状态为 SEND_OK

			log.info("send message is OK, confirm messageId: {}, sendTime: {}", messageId, sendTime);
		} else {
			log.error("send message is Fail, confirm messageId: {}, sendTime: {}", messageId, sendTime);

		}
	}
}

2.RabbitBrokerImpl
com.ccarlos.rabbit.producer.broker.RabbitBrokerImpl.sendKernel
@Autowired
private RabbitTemplateContainer rabbitTemplateContainer;
// 以topic为key做池化操作，多生产者操作，而不是单例（性能不高）
RabbitTemplate rabbitTemplate = rabbitTemplateContainer.getTemplate(message);



3-8 序列化与反序列化转换封装（22分钟）
3-8 序列化与反序列化转换封装（22分钟）
1.Serializer

/**
 * 	序列化和反序列化的接口
 * @author ccarlos
 */
public interface Serializer {

	byte[] serializeRaw(Object data);

	String serialize(Object data);

	<T> T deserialize(String content);

	<T> T deserialize(byte[] content);

}

2.SerializerFactory
public interface SerializerFactory {

	Serializer create();
}

3.JacksonSerializer
/**
 * 	$JacksonSerializer
 * @author ccarlos
 *
 */
public class JacksonSerializer implements Serializer {

    private static final Logger LOGGER = LoggerFactory.getLogger(JacksonSerializer.class);
    private static final ObjectMapper mapper = new ObjectMapper();

    static {
        mapper.disable(SerializationFeature.INDENT_OUTPUT);
        mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
        mapper.configure(JsonParser.Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER, true);
        mapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true);
        mapper.configure(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS, true);
        mapper.configure(JsonParser.Feature.ALLOW_NUMERIC_LEADING_ZEROS, true);
        mapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);
        mapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS, true);
        mapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);
    }

    private final JavaType type;

    private JacksonSerializer(JavaType type) {
        this.type = type;
    }

    public JacksonSerializer(Type type) {
        this.type = mapper.getTypeFactory().constructType(type);
    }

    public static JacksonSerializer createParametricType(Class<?> cls) {
        return new JacksonSerializer(mapper.getTypeFactory().constructType(cls));
    }

    @Override
    public byte[] serializeRaw(Object data) {
        try {
            return mapper.writeValueAsBytes(data);
        } catch (JsonProcessingException e) {
            LOGGER.error("序列化出错", e);
        }
        return null;
    }

    @Override
    public String serialize(Object data) {
        try {
            return mapper.writeValueAsString(data);
        } catch (JsonProcessingException e) {
            LOGGER.error("序列化出错", e);
        }
        return null;
    }

    @Override
    public <T> T deserialize(String content) {
        try {
            return mapper.readValue(content, type);
        } catch (IOException e) {
            LOGGER.error("反序列化出错", e);
        }
        return null;
    }

    @Override
    public <T> T deserialize(byte[] content) {
        try {
            return mapper.readValue(content, type);
        } catch (IOException e) {
            LOGGER.error("反序列化出错", e);
        }
        return null;
    }

}

4.JacksonSerializerFactory
public class JacksonSerializerFactory implements SerializerFactory {

	/** 单例模式 */
	public static final SerializerFactory INSTANCE = new JacksonSerializerFactory();

	@Override
	public Serializer create() {
		return JacksonSerializer.createParametricType(Message.class);
	}

}

5.GenericMessageConverter
/**
 * 	$GenericMessageConverter
 * @author ccarlos
 *
 */
public class GenericMessageConverter implements MessageConverter {

	private Serializer serializer;

	public GenericMessageConverter(Serializer serializer) {
		Preconditions.checkNotNull(serializer);
		this.serializer = serializer;
	}

	@Override
	public Object fromMessage(org.springframework.amqp.core.Message message) throws MessageConversionException {
		return this.serializer.deserialize(message.getBody());
	}

	@Override
	public org.springframework.amqp.core.Message toMessage(Object object, MessageProperties messageProperties)
			throws MessageConversionException {
		return new org.springframework.amqp.core.Message(this.serializer.serializeRaw(object), messageProperties);
	}

}

6.RabbitMessageConverter
/**
 * 	$RabbitMessageConverter
 *  装饰者模式或者静态代理模式
 */
public class RabbitMessageConverter implements MessageConverter {

	private GenericMessageConverter delegate;

//	private final String delaultExprie = String.valueOf(24 * 60 * 60 * 1000);

	public RabbitMessageConverter(GenericMessageConverter genericMessageConverter) {
		Preconditions.checkNotNull(genericMessageConverter);
		this.delegate = genericMessageConverter;
	}

	@Override
	public Message toMessage(Object object, MessageProperties messageProperties) throws MessageConversionException {
//		messageProperties.setExpiration(delaultExprie);
		com.ccarlos.rabbit.api.Message message = (com.ccarlos.rabbit.api.Message)object;
		messageProperties.setDelay(message.getDelayMills());
		return this.delegate.toMessage(object, messageProperties);
	}

	@Override
	public Object fromMessage(Message message) throws MessageConversionException {
		com.ccarlos.rabbit.api.Message msg = (com.ccarlos.rabbit.api.Message) this.delegate.fromMessage(message);
		return msg;
	}

}

7.RabbitTemplateContainer
// 单例模式，饥饿加载
private SerializerFactory serializerFactory = JacksonSerializerFactory.INSTANCE;

//	添加序列化反序列化和converter对象
Serializer serializer = serializerFactory.create();
GenericMessageConverter gmc = new GenericMessageConverter(serializer);
RabbitMessageConverter rmc = new RabbitMessageConverter(gmc);
newTemplate.setMessageConverter(rmc);



3-9 确认消息实现（3分钟）
 1.com.ccarlos.rabbit.producer.broker.RabbitBrokerImpl.confirmSend
@Override
   public void confirmSend(Message message) {
       message.setMessageType(MessageType.CONFIRM);
       sendKernel(message);
   }



3-10 从架构的视角分析可靠性消息投递（14分钟）