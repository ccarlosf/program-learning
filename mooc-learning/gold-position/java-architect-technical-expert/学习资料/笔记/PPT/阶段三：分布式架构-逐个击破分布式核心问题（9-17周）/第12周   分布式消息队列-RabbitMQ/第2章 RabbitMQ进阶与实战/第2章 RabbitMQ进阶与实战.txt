第2章 RabbitMQ进阶与实战
2-1 RabbitMQ学习指南（2分钟）



2-2 初识RabbitMQ核心概念-1（18分钟）



2-3 （缺）初识RabbitMQ核心概念-2（11分钟）
2-4 （缺）RabbitMQ环境搭建与控制台详解-1（29分钟）
2-5 （缺）RabbitMQ环境搭建与控制台详解-2（20分钟）
2-6（缺） RabbitMQ急速入门HelloWorld（24分钟）
2-7 （缺）Rabbitmq核心API-Exchange之Direct（16分钟）
2-8 （缺）Rabbitmq核心API-Exchange之Topic（16分钟）
2-9（缺） Rabbitmq核心API-Exchange之Fanout（6分钟）
2-10 （缺）Rabbitmq核心API-其他关键概念讲解（5分钟）
2-11 （缺）Rabbitmq高级特性-生产端可靠性投递与消费端幂等性 （22分钟）
2-12 （缺） Rabbitmq高级特性-生产端特性讲解_确认机制和返回机制 （13分钟）
2-13 （缺）Rabbitmq高级特性-消费端特性讲解_流控服务和ACK重回队列 （18:49）
2-14 （缺）高级特性-TTL消息与死信队列详解 （20分钟）
2-15 （缺）Rabbitmq集群搭建-镜像队列集群环境搭建实操 （23分钟）
2-16 RabbitMQ与SpringBoot整合_生产端-1（17:25）
2-17 RabbitMQ与SpringBoot整合_生产端-2 （13分钟）
2-18 RabbitMQ与SpringBoot整合_消费端-1 （14分钟）
2-19 RabbitMQ与SpringBoot整合_消费端-2 （13:01）

2-03 【基础额外补充-视频】哪些互联网大厂在使用rabbitmq,为什么



2-04 【基础额外补充-视频】rabbitmq高性能的原因



2-5 【基础额外补充】amqp高级消息队列协议与模型



2-06 【基础额外补充-视频】amqp核心概念讲解



2-07 【基础额外补充-视频】rabbitmq整体架构与消息流转



2-8 附：RabbitMQ急速入门



2-9 附：RabbitMQ核心API



2-10 【基础额外补充-图文】RabbitMQ高级特性



2-11 【选学：基础额外补充】消息如何保障 100% 的投递成功方案-1



2-12 【选学：基础额外补充】消息如何保障 100% 的投递成功方案-2



2-13 【选学：基础额外补充】幂等性概念及业界主流解决方案



2-14 rabbitmq与springboot整合_生产端-1
2-14 rabbitmq与springboot整合_生产端-1
1.配置文件
server.servlet.context-path=/
server.port=8001

#spring.rabbitmq.addresses=192.168.11.71:5672,192.168.11.72:5672,192.168.11.71:5673
spring.rabbitmq.addresses=127.0.0.1:5672
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest
spring.rabbitmq.virtual-host=/
spring.rabbitmq.connection-timeout=15000

##	使用启用消息确认模式
spring.rabbitmq.publisher-confirms=true

## 	设置return消息模式，注意要和mandatory一起去配合使用
##spring.rabbitmq.publisher-returns=true
##spring.rabbitmq.template.mandatory=true

spring.application.name=rabbit-producer
spring.http.encoding.charset=UTF-8
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
spring.jackson.time-zone=GMT+8
spring.jackson.default-property-inclusion=NON_NULL

2.pom文件
<!-- springboot rabbitmq(amqp) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>



2-15 rabbitmq与springboot整合_生产端-2
2-15 rabbitmq与springboot整合_生产端-2
1.代码实现
@Component
public class RabbitSender {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    /**
     * 这里就是确认消息的回调监听接口，用于确认消息是否被broker所收到
     */
    final ConfirmCallback confirmCallback = new ConfirmCallback() {
        /**
         *    @param correlationData 作为一个唯一的标识
         *    @param ack broker 是否落盘成功
         *    @param cause 失败的一些异常信息
         */
        @Override
        public void confirm(CorrelationData correlationData, boolean ack, String cause) {
            System.err.println("消息ACK结果:" + ack + ", correlationData: " + correlationData.getId());
        }
    };

    /**
     * 对外发送消息的方法
     *
     * @param message    具体的消息内容
     * @param properties 额外的附加属性
     * @throws Exception
     */
    public void send(Object message, Map<String, Object> properties) throws Exception {

        MessageHeaders mhs = new MessageHeaders(properties);
        Message<?> msg = MessageBuilder.createMessage(message, mhs);

        rabbitTemplate.setConfirmCallback(confirmCallback);

        // 	指定业务唯一的iD
        CorrelationData correlationData = new CorrelationData(UUID.randomUUID().toString());

        MessagePostProcessor mpp = new MessagePostProcessor() {

            @Override
            public org.springframework.amqp.core.Message postProcessMessage(org.springframework.amqp.core.Message message)
                    throws AmqpException {
                System.err.println("---> post to do: " + message);
                return message;
            }
        };

        rabbitTemplate.convertAndSend("exchange-1",
                "springboot.rabbit",
                msg, mpp, correlationData);

    }


}



2-16 rabbitmq与springboot整合_消费端-1
2-16 rabbitmq与springboot整合_消费端-1
1.配置文件
server.servlet.context-path=/
server.port=8002

#spring.rabbitmq.addresses=192.168.11.71:5672,192.168.11.72:5672,192.168.11.71:5673
spring.rabbitmq.addresses=127.0.0.1:5672
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest
spring.rabbitmq.virtual-host=/
spring.rabbitmq.connection-timeout=15000

## 	表示消费者消费成功消息以后需要手工的进行签收(ack)，默认为auto
spring.rabbitmq.listener.simple.acknowledge-mode=manual
spring.rabbitmq.listener.simple.concurrency=5
spring.rabbitmq.listener.simple.max-concurrency=10
spring.rabbitmq.listener.simple.prefetch=1


##	作业：
##	最好不要在代码里写死配置信息，尽量使用这种方式也就是配置文件的方式
##	在代码里使用 	${}	方式进行设置配置: ${spring.rabbitmq.listener.order.exchange.name}
spring.rabbitmq.listener.order.exchange.name=order-exchange
spring.rabbitmq.listener.order.exchange.durable=true
spring.rabbitmq.listener.order.exchange.type=topic
spring.rabbitmq.listener.order.exchange.key=order.*

spring.application.name=rabbit-producer
spring.http.encoding.charset=UTF-8
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
spring.jackson.time-zone=GMT+8
spring.jackson.default-property-inclusion=NON_NULL

2.pom文件
   <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <!-- springboot rabbitmq(amqp) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>

3.代码实现
@Component
public class RabbitReceive {

	/**
	 * 	组合使用监听
	 * 	@RabbitListener @QueueBinding @Queue @Exchange
	 * @param message
	 * @param channel
	 * @throws Exception
	 */
	@RabbitListener(bindings = @QueueBinding(
					value = @Queue(value = "queue-1", durable = "true"),
					exchange = @Exchange(name = "exchange-1",
					durable = "true",
					type = "topic",
					ignoreDeclarationExceptions = "true"),
					key = "springboot.*"
				)
			)
	@RabbitHandler
	public void onMessage(Message message, Channel channel) throws Exception {
		//	1. 收到消息以后进行业务端消费处理
		System.err.println("-----------------------");
		System.err.println("消费消息:" + message.getPayload());

		//  2. 处理成功之后 获取deliveryTag 并进行手工的ACK操作, 因为我们配置文件里配置的是 手工签收
		//	spring.rabbitmq.listener.simple.acknowledge-mode=manual
		Long deliveryTag = (Long)message.getHeaders().get(AmqpHeaders.DELIVERY_TAG);
		channel.basicAck(deliveryTag, false);
	}
}

2-17 rabbitmq与springboot整合_消费端-2
1.单元测试
@Test
	public void testSender() throws Exception {
		Map<String, Object> properties = new HashMap<String, Object>();
		properties.put("attr1", "12345");
		properties.put("attr2", "abcde");
		reRabbitSender.send("蔡少辉爱陈燕!", properties);

		Thread.sleep(10000);
	}



2-18 【选学：基础额外补充】集群架构模式-主备模式（warren)



2-19 【选学：基础额外补充】集群架构模式-远程模式（shove)



2-20 【选学：基础额外补充】集群架构模式-镜像模式（mirror)